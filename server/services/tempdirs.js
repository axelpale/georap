
const shortid = require('shortid');
const moment = require('moment');
const fs = require('fs-extra');
const path = require('path');
const asyn = require('async');

const FORMAT = 'YYYY-MM-DD';

const generateName = function () {
  return moment().format(FORMAT) + '_' + shortid.generate();
};

const validateName = function (name) {
  // Ensure the name has correct syntax
  return moment(name.substr(0, FORMAT.length), FORMAT).isValid();
};



const TempDir = function (abs) {
  this.abs = abs;
};

TempDir.prototype.getName = function () {
  return path.basename(this.abs);
};

TempDir.prototype.getPath = function () {
  return this.abs;
};

TempDir.prototype.getAgeSec = function (callback) {
  // Age from last change
  //
  // Parameters
  //   callback
  //     function (err, seconds)
  fs.stat(this.abs, (err, stat) => {
    if (err) {
      return callback(err);
    }
    const changeTime = moment(stat.ctime);
    const age = moment().diff(changeTime, 'seconds');
    return callback(null, age);
  });
};

TempDir.prototype.remove = function (maxAgeSec, callback) {
  // Parameters:
  //   maxAgeSec
  //     integer
  //   callback
  //     function (err, wasRemoved)
  //
  const self = this;

  this.getAgeSec((err, age) => {
    if (err) {
      return callback(err);
    }

    if (age > maxAgeSec) {
      fs.remove(self.abs, (errr) => {
        if (errr) {
          return callback(errr);
        }
        return callback(null, true);
      });
    } else {
      return callback(null, false);
    }
  });
};



exports.getDirs = function (root, callback) {
  fs.readdir(root, (err, files) => {
    if (err) {
      return callback(err);
    }

    // Prevent listing files and directories not created by tempdirs.js
    const validFiles = files.filter((fname) => {
      return validateName(fname);
    });

    const tempDirs = validFiles.map((fname) => {
      return new TempDir(path.join(root, fname));
    });

    return callback(null, tempDirs);
  });
};

exports.getDir = function (root, name, callback) {
  // Parameters
  //   root
  //     path to the root temp folder of your app
  //   name
  //     OPTIONAL name of the directory. A new directory will be created
  //     if name is omitted. Use only names generated by tempdirs.js
  //   callback
  //     function (err, tempDir)

  if (typeof name === 'function' && typeof callback === 'undefined') {
    // Create new directory
    callback = name;
    name = generateName();
  } else if (!validateName(name)) {
    // Name was given by the user and is not valid.
    return callback(new Error('Invalid name format'));
  }

  const abs = path.resolve(root, name);

  fs.ensureDir(abs, (err) => {
    if (err) {
      return callback(err);
    }

    return callback(null, new TempDir(abs));
  });

};

exports.removeOlderThan = function (root, maxAgeSec, callback) {
  // Remove all dirs under root that are not changed at least maxAgeSec time.
  //
  // Parameters
  //   root
  //     path
  //   maxAgeSec
  //     integer
  //   callback
  //     function (err, removedTempDirNames)
  //
  exports.getDirs(root, (err, tempDirs) => {
    if (err) {
      return callback(err);
    }

    const removedNames = [];

    asyn.eachSeries(tempDirs, (item, next) => {
      item.remove(maxAgeSec, (errr, wasRemoved) => {
        if (errr) {
          return next(errr);
        }

        if (wasRemoved) {
          removedNames.push(item.getName());
        }

        return next();
      });
    }, (erra) => {
      if (erra) {
        return callback(erra);
      }

      return callback(null, removedNames);
    });
  });
};
